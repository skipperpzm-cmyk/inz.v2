-- 0023_add_public_id_safe.sql
-- Up migration: add `public_id` (varchar(8)) to `public.profiles`, backfill existing rows,
-- create uniqueness constraint/index, and install a trigger that auto-generates
-- an 8-digit numeric `public_id` for future inserts.
--
-- Purpose:
--  - Provide a short, stable, public identifier for user profiles used in public URLs
--    (e.g. /profile/<public_id>).
--  - Keep `username_display` and other username fields for display purposes only.
--
-- Summary of guarantees & behavior:
--  - `public_id` is 8 characters and consists of digits [0-9]. It is unique and NOT NULL.
--  - Existing rows are backfilled with generated unique 8-digit numeric strings.
--  - A UNIQUE index enforces uniqueness at the DB level.
--  - Future inserts will have `public_id` auto-generated by a trigger that uses an
--    advisory lock to serialize generation and avoid race conditions. The trigger
--    will retry generation until a unique value is found (with a safety limit).
--
-- Verification steps (after running `up`):
--  1. Confirm `public.profiles.public_id` exists, is NOT NULL, and has a unique index.
--     SELECT count(*) FROM public.profiles WHERE public_id IS NULL; -- should be 0
--     SELECT count(public_id), count(DISTINCT public_id) FROM public.profiles; -- should be equal
--  2. Register a new user and verify the `profiles` row has a `public_id` (and it's unique).
--  3. Navigate to `/profile/<public_id>` to confirm public page loads and shows `username_display`.
--  4. Change a username; confirm `/profile/<public_id>` still resolves to the same profile and shows updated `username_display`.
--
-- Important: take a full DB backup before running on production (pg_dump or snapshot).

BEGIN;

-- 1) Add column (varchar(8)). Do not mark NOT NULL until backfill completes.
ALTER TABLE IF EXISTS public.profiles
  ADD COLUMN IF NOT EXISTS public_id varchar(8);

-- 2) Backfill existing profiles that lack public_id.
--    This loop attempts to generate a unique 8-digit numeric string per row.
--    It checks against current table contents to avoid duplicates.
DO $$
DECLARE
  r RECORD;
  new_id text;
  tries integer;
BEGIN
  FOR r IN SELECT id FROM public.profiles WHERE public_id IS NULL LOOP
    tries := 0;
    LOOP
      -- generate an 8-digit number where the leading digit is non-zero (range 10000000..99999999)
      new_id := lpad(((floor(random()*90000000) + 10000000)::int)::text, 8, '0');

      -- ensure uniqueness in the current table snapshot
      IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE public_id = new_id) THEN
        UPDATE public.profiles SET public_id = new_id WHERE id = r.id;
        EXIT;
      END IF;

      tries := tries + 1;
      IF tries > 100 THEN
        RAISE EXCEPTION 'unable to generate unique public_id for profile % after % attempts', r.id, tries;
      END IF;
    END LOOP;
  END LOOP;
END$$;

-- 3) Create unique index to enforce uniqueness (name chosen explicitly)
-- NOTE: this locks the table briefly on creation; run during maintenance if table is very large.
CREATE UNIQUE INDEX IF NOT EXISTS profiles_public_id_idx ON public.profiles (public_id);

-- 4) Make column NOT NULL now that we've backfilled values
ALTER TABLE public.profiles ALTER COLUMN public_id SET NOT NULL;

-- 5) Create trigger function to auto-generate `public_id` for new inserts.
--    Use `pg_advisory_xact_lock` to serialize generation across concurrent transactions
--    so that checks for existence are reliable and avoid race conditions.
CREATE OR REPLACE FUNCTION public.generate_public_id() RETURNS trigger AS $$
DECLARE
  new_id text;
  tries integer := 0;
  lock_key bigint := 987654321; -- arbitrary constant for advisory lock
BEGIN
  -- If caller provided a public_id explicitly, respect it
  IF NEW.public_id IS NOT NULL THEN
    RETURN NEW;
  END IF;

  -- Acquire an advisory transaction-level lock so generation+check is serialized
  PERFORM pg_advisory_xact_lock(lock_key);

  LOOP
    new_id := lpad(((floor(random()*90000000) + 10000000)::int)::text, 8, '0');
    -- check for collision in the table
    IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE public_id = new_id) THEN
      NEW.public_id := new_id;
      RETURN NEW;
    END IF;
    tries := tries + 1;
    IF tries > 200 THEN
      RAISE EXCEPTION 'unable to generate unique public_id after % attempts', tries;
    END IF;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 6) Install trigger if not already present
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'before_insert_generate_public_id'
  ) THEN
    CREATE TRIGGER before_insert_generate_public_id
      BEFORE INSERT ON public.profiles
      FOR EACH ROW
      EXECUTE FUNCTION public.generate_public_id();
  END IF;
END$$;

COMMIT;

-- Down (rollback) statements follow. Running the down migration will attempt to
-- remove the trigger, function, index, and column added by this migration.
-- Use with caution: dropping the column will permanently remove the public_id values.
--
-- To rollback manually, run the following in a transaction:
--
-- BEGIN;
-- DROP TRIGGER IF EXISTS before_insert_generate_public_id ON public.profiles;
-- DROP FUNCTION IF EXISTS public.generate_public_id();
-- DROP INDEX IF EXISTS profiles_public_id_idx;
-- ALTER TABLE IF EXISTS public.profiles DROP COLUMN IF EXISTS public_id;
-- COMMIT;

-- End of migration
